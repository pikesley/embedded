import Sound.Tidal.OscStream
import Sound.OSC.FD
import Sound.OSC.Datum
import qualified System.Hardware.Serialport as SP
import Control.Monad
import Control.Monad.Loops
import qualified Data.ByteString.Char8 as B
import Data.Colour.SRGB
import Data.Colour.Names

let light :: Shape
    light = Shape {params = [s_p,
                             pan_p,
                             begin_p,
                             end_p
                             ],
                   cpsStamp = True,
                   latency = 0.04
                  }
    lightSlang = OscSlang {
      path = "/lightrgb",
      timestamp = NoStamp,
      namedParams = False,
      preamble = []
      }
    lightBackend = do s <- makeConnection "127.0.0.1" 9099 lightSlang
                      return $ Backend s (\_ _ _ -> return ())
    lightServer = do s <- udpServer "127.0.0.1" 9099
                     output <- SP.openSerial "/dev/ttyUSB0" SP.defaultSerialSettings
                     forkIO $ lightLoop s output
    lightLoop s output = do m <- recvMessage s
                            act m output
                            lightLoop s output
    act (Just (Message "/light" [Float cps', ASCII_String s', Float pan', Float begin', Float end'])) output =
      do let (r,g,b) = s2rgb $ show s'
         leftch = cos((pi / 2) * pan')
         rightch = sin((pi / 2) * pan')
         sendLeft r g b leftch
         sendRight r g b rightch
         return ()
    act ( Just (Message "/lightrgb" [ASCII_String s])) output =
      do SP.send output $ B.pack $ (show s) ++ "\r"
         return ()
    act m output = do putStrLn $ "message: " ++ show m
                      return ()
    to256 f = show $ floor (f * 255)
    lightStream = do backend <- lightBackend
                     stream backend light
    c2rgb = ((\c -> (to256 $ channelRed c) ++ "r" ++ (to256 $ channelGreen c) ++ "g" ++ (to256 $ channelBlue c) ++ "b") . toSRGB)
    s2rgb = ((\c -> (channelRed c, channelGreen c, channelBlue c)) . toSRGB . stringToColour)

let sendLeft r g b 0 = return ()
    sendLeft r g b l = do SP.send output $ B.pack $ to256 r ++ "r\r"
                          SP.send output $ B.pack $ to256 g ++ "g\r"
                          SP.send output $ B.pack $ to256 b ++ "b\r"
                          SP.send output $ B.pack $ to256 l ++ "l\r"
    sendRight r g b 0 = return ()
    sendRight r g b l = do SP.send output $ B.pack $ to256 r ++ "R\r"
                           SP.send output $ B.pack $ to256 g ++ "G\r"
                           SP.send output $ B.pack $ to256 b ++ "B\r"
                           SP.send output $ B.pack $ to256 l ++ "L\r"


s2rgb <$> (p "hello" :: Pattern String)

lightServer
l1 <- lightStream

l1 $ rgb $ c2rgb  $ (p "{purple pink, orange blue green}" :: Pattern ColourD)
l1 $ rgb "x"
c2rgb red

l1 silence
l1 $ red "[0 0.1]*16" # green (slow 2 saw1) # blue (slow 4 sine1)
  
l1 $ red "0"

output <- SP.openSerial "/dev/ttyUSB0" SP.defaultSerialSettings
let to256 f = show $ floor (f * 255)

SP.send output $ B.pack $ "r\r"

l1 $ red "0.5*8"

lightServer

let to256 f = show $ floor (f * 255)

