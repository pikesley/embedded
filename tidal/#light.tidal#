import Sound.Tidal.OscStream
import Sound.OSC.FD
import Sound.OSC.Datum
import qualified System.Hardware.Serialport as SP
import Control.Monad
import Control.Monad.Loops
import qualified Data.ByteString.Char8 as B
import Data.Colour.SRGB
import Data.Colour.Names

data Sound = Sound {rv :: Float,
                    gv :: Float,
                    b :: Float,
                    pan :: Float
                   }

let light :: Shape
    light = Shape {params = [s_p,
                             pan_p,
                             begin_p,
                             end_p
                             ],
                   cpsStamp = True,
                   latency = 0.3
                  }
    lightSlang = OscSlang {
      path = "/lightrgb",
      timestamp = NoStamp,
      namedParams = False,
      preamble = []
      }
    lightBackend = do s <- makeConnection "127.0.0.1" 9099 lightSlang
                      return $ Backend s (\_ _ _ -> return ())
    lightServer = do s <- udpServer "127.0.0.1" 9099
                     output <- SP.openSerial "/dev/ttyUSB0" (SP.defaultSerialSettings {SP.commSpeed = SP.CS115200})
                     forkIO $ lightLoop s output
    lightLoop s output = do m <- recvMessage s
                            act m output
                            lightLoop s output
    act (Just (Message "/lightrgb" [Float cps', ASCII_String s', Float pan', Float begin', Float end'])) output =
      do let (r,g,b) = s2rgb $ show s'
             leftch = cos((pi / 2) * pan')
             rightch = sin((pi / 2) * pan')
         sendLeft output r g b leftch
         sendRight output r g b rightch
         return ()
    act ( Just (Message "/lightrgb" [ASCII_String s])) output =
      do SP.send output $ B.pack $ (show s) ++ "\r"
         return ()
    act m output = do putStrLn $ "message: " ++ show m
                      return ()
    to256 f = show $ floor (f * 255)
    lightStream = do backend <- lightBackend
                     stream backend light
    c2rgb = ((\c -> (to256 $ channelRed c) ++ "r" ++ (to256 $ channelGreen c) ++ "g" ++ (to256 $ channelBlue c) ++ "b") . toSRGB)
    s2rgb = ((\c -> (channelRed c, channelGreen c, channelBlue c)) . toSRGB . stringToColour)
    -- sendLeft _ _ _ _ 0 = return ()
    sendLeft output r g b l = do SP.send output $ B.pack $ to256 r ++ "r\r"
                                 SP.send output $ B.pack $ to256 g ++ "g\r"
                                 SP.send output $ B.pack $ to256 b ++ "b\r"
                                 SP.send output $ B.pack $ to256 l ++ "l\r"
                                 return ()
    -- sendRight _ _ _ _ 0 = return ()
    sendRight output r g b l = do SP.send output $ B.pack $ to256 r ++ "R\r"
                                  SP.send output $ B.pack $ to256 g ++ "G\r"
                                  SP.send output $ B.pack $ to256 b ++ "B\r"
                                  SP.send output $ B.pack $ to256 l ++ "L\r"
                                  return ()

lightServer
l1 <- lightStream

let x1 p = d1 p >> l1 p

x1 $ jux (rev . density 2) $ sound "bd cp sn:2 bd*8"
  # pan sine1

x1 $ jux rev $ s "cp bd cp bd*3"

x1 silence

l1 $ s "orange*8" # pan (slow 4 sine1)
l1 silence
l1 $ s "red green" # pan "0"

l1 $ s (p "{purple pink, orange blue green}" :: Pattern ColourD)
l1 $ rgb "x"
c2rgb red

l1 silence
l1 $ red "[0 0.1]*16" # green (slow 2 saw1) # blue (slow 4 sine1)
  
l1 $ red "0"

x1 $ sound "bd 0 0 0"

output <- SP.openSerial "/dev/ttyUSB0" SP.defaultSerialSettings
let to256 f = show $ floor (f * 255)

SP.send output $ B.pack $ "r\r"

l1 $ red "0.5*8"

lightServer

let to256 f = show $ floor (f * 255)

